---
import ThemeToggle from "./ThemeToggle";
import TablerIcon from "./TablerIcon.astro";
import LogoIcon from "./LogoIcon.astro";

const navItems = [
  { key: "work", href: "/work", label: "Work" },
  { key: "about", href: "/about", label: "About" },
  { key: "contact", href: "/contact", label: "Contact" },
] as const;

const currentPath = Astro.url.pathname;
const activeKey = currentPath.startsWith("/about")
  ? "about"
  : currentPath.startsWith("/work")
    ? "work"
    : currentPath.startsWith("/contact")
      ? "contact"
      : null;
---

<header class="relative z-40" data-scroll-header transition:name="site-header">
  <div class="mx-auto w-full px-[32px] pt-[36px] sm:px-10 sm:pt-[40px] lg:px-16 lg:pt-[48px]">
    <nav class="flex items-center justify-between lg:min-h-[140px] lg:items-start" aria-label="Główna nawigacja">
      <a
        href="/"
        class="inline-flex items-center lg:py-[12px]"
        aria-label="Strona główna"
        transition:name="site-brand"
        transition:persist
      >
        <span class="h-[16px] w-auto lg:h-[18px] text-[var(--color-text)]">
          <LogoIcon class="size-6" />
        </span>
      </a>

      <div class="flex items-center gap-[24px] sm:gap-[32px] lg:items-start lg:gap-[64px]">
        <ul class="hidden items-start gap-[64px] text-[var(--color-text)] lg:flex">
          {
            navItems.map((item) => {
              const isActive = item.key === activeKey;

              return (
                <li>
                  <a
                    href={item.href}
                    aria-current={isActive ? "page" : undefined}
                    class:list={[
                      "block whitespace-nowrap transition-colors duration-200 focus-visible:outline-2 focus-visible:outline-offset-4 focus-visible:outline-[var(--color-text)]",
                      isActive
                        ? "font-medium text-[128px] leading-[1] tracking-[-0.025em]"
                        : "py-[6px] text-[24px] leading-[32px]",
                    ]}
                    transition:name={`nav-item-${item.key}`}
                  >
                    {item.label}
                  </a>
                </li>
              );
            })
          }
        </ul>

        <div transition:name="theme-toggle" transition:persist>
          <ThemeToggle
            client:load
            className="group inline-flex size-[32px] cursor-pointer items-center justify-center p-[4px] text-[var(--color-text)] sm:size-[36px] sm:p-[5px] lg:size-[44px] lg:p-[6px]"
            iconClassName="size-6 transition-transform duration-200 ease-out group-hover:scale-105 group-hover:rotate-6 sm:size-7 lg:size-8"
          />
        </div>

        <div class="lg:hidden" data-mobile-menu>
          <button
            type="button"
            data-mobile-open
            class="inline-flex size-[32px] items-center justify-center rounded-full text-[var(--color-text)] sm:size-[36px] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--color-text)]"
            aria-label="Otwórz menu"
            aria-expanded="false"
            aria-controls="mobile-menu-panel"
          >
            <TablerIcon name="menu-2" class="size-6" />
          </button>

          <div
            class="fixed inset-0 z-[90] opacity-0 pointer-events-none transition-opacity duration-200"
            data-mobile-overlay
            aria-hidden="true"
          >
            <button
              type="button"
              class="absolute inset-0 bg-black/10"
              data-mobile-backdrop
              tabindex="-1"
              aria-label="Zamknij menu"
            ></button>

            <div
              id="mobile-menu-panel"
              class="absolute right-0 top-0 flex h-full w-[53%] min-w-[200px] max-w-[220px] translate-x-full flex-col items-end bg-[var(--color-background)] px-[32px] pb-[40px] pt-[36px] transition-transform duration-200 sm:w-[40%] sm:min-w-[280px] sm:max-w-[360px] sm:px-[36px] sm:pb-[44px] sm:pt-[40px]"
              data-mobile-panel
              role="dialog"
              aria-modal="true"
              aria-label="Menu nawigacji"
            >
              <button
                type="button"
                data-mobile-close
                class="inline-flex size-[32px] items-center justify-center rounded-full text-[var(--color-text)] sm:size-[36px] focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-[var(--color-text)]"
                aria-label="Zamknij menu"
              >
                <TablerIcon name="x" class="size-6" />
              </button>

              <ul class="mt-[56px] flex flex-col items-end gap-[16px] text-[var(--color-text)] sm:mt-[64px] sm:gap-[20px]">
                {
                  navItems.map((item) => {
                    const isActive = item.key === activeKey;

                    return (
                      <li>
                        <a
                          href={item.href}
                          data-mobile-link
                          aria-current={isActive ? "page" : undefined}
                          class:list={[
                            "block focus-visible:outline-2 focus-visible:outline-offset-4 focus-visible:outline-[var(--color-text)]",
                            isActive
                              ? "font-medium text-[40px] leading-[1] tracking-[-0.0375em]"
                              : "text-[16px] leading-none",
                          ]}
                        >
                          {item.label}
                        </a>
                      </li>
                    );
                  })
                }
              </ul>
            </div>
          </div>
        </div>
      </div>
    </nav>
  </div>
</header>

<script is:inline>
  (() => {
    const STATE_KEY = "__portfolioMobileMenuState";
    const state = window[STATE_KEY] ?? (window[STATE_KEY] = {});

    const focusablesSelector =
      'a[href], button:not([disabled]), [tabindex]:not([tabindex="-1"])';

    const setup = () => {
      if (typeof state.cleanup === "function") {
        state.cleanup();
      }

      const previousFocus = new WeakMap();
      const controller = new AbortController();
      const { signal } = controller;

      const getRoot = (target) =>
        target instanceof Element ? target.closest("[data-mobile-menu]") : null;

      const getRoots = () => Array.from(document.querySelectorAll("[data-mobile-menu]"));

      const getElements = (root) => ({
        openButton: root.querySelector("[data-mobile-open]"),
        closeButton: root.querySelector("[data-mobile-close]"),
        overlay: root.querySelector("[data-mobile-overlay]"),
        panel: root.querySelector("[data-mobile-panel]"),
      });

      const isOpen = (root) => {
        const { openButton } = getElements(root);
        return openButton?.getAttribute("aria-expanded") === "true";
      };

      const syncBodyScrollLock = () => {
        const hasOpenMenu = getRoots().some((root) => isOpen(root));
        document.body.classList.toggle("mobile-menu-open", hasOpenMenu);
      };

      const closeMenu = (root, restoreFocus = true) => {
        const { openButton, overlay, panel } = getElements(root);
        if (!openButton || !overlay || !panel) return;

        openButton.setAttribute("aria-expanded", "false");
        overlay.setAttribute("aria-hidden", "true");
        root.classList.remove("is-open");

        overlay.classList.remove("opacity-100", "pointer-events-auto");
        overlay.classList.add("opacity-0", "pointer-events-none");
        panel.classList.remove("translate-x-0");
        panel.classList.add("translate-x-full");

        syncBodyScrollLock();

        const savedFocus = previousFocus.get(root);
        if (restoreFocus && savedFocus instanceof HTMLElement) {
          savedFocus.focus();
        }
        previousFocus.delete(root);
      };

      const closeAllMenus = (restoreFocus = false) => {
        getRoots().forEach((root) => {
          if (isOpen(root)) {
            closeMenu(root, restoreFocus);
          }
        });
      };

      const openMenu = (root) => {
        const { openButton, closeButton, overlay, panel } = getElements(root);
        if (!openButton || !closeButton || !overlay || !panel) return;

        closeAllMenus(false);

        const activeElement = document.activeElement;
        previousFocus.set(root, activeElement instanceof HTMLElement ? activeElement : null);

        openButton.setAttribute("aria-expanded", "true");
        overlay.setAttribute("aria-hidden", "false");
        root.classList.add("is-open");

        overlay.classList.remove("opacity-0", "pointer-events-none");
        overlay.classList.add("opacity-100", "pointer-events-auto");
        panel.classList.remove("translate-x-full");
        panel.classList.add("translate-x-0");

        syncBodyScrollLock();
        requestAnimationFrame(() => closeButton.focus());
      };

      document.addEventListener(
        "click",
        (event) => {
          const target = event.target;
          if (!(target instanceof Element)) return;

          const openTrigger = target.closest("[data-mobile-open]");
          if (openTrigger) {
            const root = getRoot(openTrigger);
            if (!root) return;
            event.preventDefault();
            openMenu(root);
            return;
          }

          const closeTrigger = target.closest("[data-mobile-close], [data-mobile-backdrop]");
          if (closeTrigger) {
            const root = getRoot(closeTrigger);
            if (!root) return;
            event.preventDefault();
            closeMenu(root, true);
            return;
          }

          const navLink = target.closest("[data-mobile-link]");
          if (navLink) {
            const root = getRoot(navLink);
            if (!root) return;
            closeMenu(root, false);
          }
        },
        { signal }
      );

      document.addEventListener(
        "keydown",
        (event) => {
          const root = getRoots().find((menuRoot) => isOpen(menuRoot));
          if (!root) return;

          const { panel } = getElements(root);
          if (!panel) return;

          if (event.key === "Escape") {
            event.preventDefault();
            closeMenu(root, true);
            return;
          }

          if (event.key !== "Tab") return;

          const panelFocusable = Array.from(panel.querySelectorAll(focusablesSelector)).filter(
            (element) =>
              element instanceof HTMLElement &&
              !element.hasAttribute("disabled") &&
              element.tabIndex !== -1
          );

          if (panelFocusable.length === 0) return;

          const first = panelFocusable[0];
          const last = panelFocusable[panelFocusable.length - 1];

          if (event.shiftKey && document.activeElement === first) {
            event.preventDefault();
            last.focus();
          } else if (!event.shiftKey && document.activeElement === last) {
            event.preventDefault();
            first.focus();
          }
        },
        { signal }
      );

      window.addEventListener(
        "resize",
        () => {
          if (window.matchMedia("(min-width: 1024px)").matches) {
            closeAllMenus(false);
          }
        },
        { signal }
      );

      document.addEventListener(
        "astro:before-swap",
        () => {
          closeAllMenus(false);
        },
        { signal }
      );

      state.cleanup = () => {
        closeAllMenus(false);
        controller.abort();
      };
    };

    if (!state.pageLoadBound) {
      document.addEventListener("astro:page-load", setup);
      state.pageLoadBound = true;
    }

    setup();
  })();
</script>

<style>
  [data-scroll-header] {
    position: relative;
    z-index: 40;
    border-bottom: 1px solid transparent;
    opacity: 1;
  }

  [data-scroll-header].is-floating {
    position: sticky;
    inset-inline: 0;
    top: 0;
    z-index: 70;
    background: var(--color-background);
    border-bottom-color: var(--color-divider);
    transform: translateY(0);
    transition:
      transform 260ms ease,
      opacity 260ms ease;
    will-change: transform, opacity;
  }

  [data-scroll-header].is-floating.is-hidden {
    transform: translateY(-100%);
    opacity: 0.01;
  }

  [data-scroll-header].is-no-transition {
    transition: none;
  }

  :global(body.mobile-menu-open) {
    overflow: hidden;
  }
</style>

<script is:inline>
  (() => {
    const STATE_KEY = "__portfolioHeaderRevealState";
    const state =
      window[STATE_KEY] ??
      (window[STATE_KEY] = {
        pageLoadBound: false,
        cleanup: null,
      });

    const setup = () => {
      if (typeof state.cleanup === "function") {
        state.cleanup();
      }

      const header = document.querySelector("[data-scroll-header]");
      if (!(header instanceof HTMLElement)) return;

      let lastY = window.scrollY;
      let direction = "down";
      let directionDistance = 0;
      let isTicking = false;
      state.isFloating = false;
      state.isHidden = false;
      const revealAfterY = 260;
      const toggleVisibilityDelta = 12;
      const revealFromBottomDelta = 56;
      const revealAfterDownPauseMs = 140;
      let maxYSinceHidden = window.scrollY;
      let lastDownAt = performance.now();
      let transitionResetRaf = 0;
      const applyFloatingState = () => {
        if (state.isFloating) {
          header.classList.add("is-floating");
        } else {
          header.classList.remove("is-floating");
        }
      };

      const hideImmediatelyOnEnterFloating = () => {
        if (transitionResetRaf) {
          cancelAnimationFrame(transitionResetRaf);
        }

        header.classList.add("is-no-transition");
        applyFloatingState();
        header.classList.add("is-hidden");

        transitionResetRaf = requestAnimationFrame(() => {
          transitionResetRaf = 0;
          header.classList.remove("is-no-transition");
        });
      };

      const processScroll = () => {
        isTicking = false;
        const currentY = window.scrollY;
        const now = performance.now();
        const rawDelta = currentY - lastY;
        const absDelta = Math.abs(rawDelta);

        if (absDelta < 1) return;
        const nextDirection = rawDelta > 0 ? "down" : "up";

        if (nextDirection === direction) {
          directionDistance += absDelta;
        } else {
          direction = nextDirection;
          directionDistance = absDelta;
        }

        if (document.body.classList.contains("mobile-menu-open")) {
          applyFloatingState();
          header.classList.remove("is-hidden");
          state.isHidden = false;
          lastY = currentY;
          return;
        }

        if (currentY <= 2) {
          state.isFloating = false;
          state.isHidden = false;
          applyFloatingState();
          header.classList.remove("is-hidden");
          direction = "down";
          directionDistance = 0;
          lastY = currentY;
          return;
        }

        if (!state.isFloating && currentY > revealAfterY) {
          state.isFloating = true;
          state.isHidden = true;
          hideImmediatelyOnEnterFloating();
          maxYSinceHidden = currentY;
          directionDistance = 0;
        }

        if (!state.isFloating) {
          applyFloatingState();
          header.classList.remove("is-hidden");
          lastY = currentY;
          return;
        }

        if (direction === "down") {
          lastDownAt = now;
          maxYSinceHidden = Math.max(maxYSinceHidden, currentY);
        }

        if (direction === "down" && directionDistance > toggleVisibilityDelta && !state.isHidden) {
          state.isHidden = true;
          header.classList.add("is-hidden");
          maxYSinceHidden = currentY;
          directionDistance = 0;
        } else if (
          direction === "up" &&
          directionDistance > toggleVisibilityDelta &&
          state.isHidden &&
          maxYSinceHidden - currentY > revealFromBottomDelta &&
          now - lastDownAt > revealAfterDownPauseMs
        ) {
          state.isHidden = false;
          header.classList.remove("is-hidden");
          directionDistance = 0;
        }

        lastY = currentY;
      };

      const onScroll = () => {
        if (isTicking) return;
        isTicking = true;
        requestAnimationFrame(processScroll);
      };

      window.addEventListener("scroll", onScroll, { passive: true });
      processScroll();

      state.cleanup = () => {
        window.removeEventListener("scroll", onScroll);
        if (transitionResetRaf) {
          cancelAnimationFrame(transitionResetRaf);
          transitionResetRaf = 0;
        }
        header.classList.remove("is-no-transition");
        state.isFloating = false;
        applyFloatingState();
        header.classList.remove("is-hidden");
        state.isHidden = false;
      };
    };

    setup();
    if (!state.pageLoadBound) {
      document.addEventListener("astro:page-load", setup);
      state.pageLoadBound = true;
    }
  })();
</script>
